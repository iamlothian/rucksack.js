var $RSConfig=!$RSConfig?{}:$RSConfig,$rucksack=$rucksack||function(n){"use strict";var r=n.DEBUG||!1,l=n.ERROR_CALLBACK||null,a=!1,i={},t={},u={},e=/([a-zA-Z]+\d*[\.\_]?)+?[a-zA-Z\d]/,o=new RegExp(/[a-zA-Z]+\d*:/.source+e.source,"g"),nt=new RegExp(o.source+"( as )"+o.source),v=/\(([^)]+)/,tt=/\s*,\s*/,it=/^\[object(.*)\]$/,rt=function(){r&&(i={},t={},u={},g=h(c,{sealed:!0}),console.log("############## RESET ##############"))},s=function(n){return Object.prototype.toString.call(n).match(it)[1].toLowerCase().replace(/ /g,"")},y=function(n){return n.toString().match(v)[1].split(tt)},f=function(n){var t="";return!n?t="undefined":n.dependencies?t="linking":!n||(t="compiled"),t},ut=function(n,t){if(!e.test(t))throw new Error(" Invalid module Key ["+t+"] must regex "+e.toString());return t.indexOf(n)===0?t:n+":"+t},ft=function(n){var t=n.length==1?[]:n.slice(0,n.length-1),u=[],s={};for(var i in t)if(nt.test(t[i])){console.log(t[i]);var f=t[i].match(o),e=f[0],h=f[1];r&&console.log("INTERFACE: ["+h+"] for ["+e+"]",f);u.push(e);s[e]=h}else u.push(t[i]);return{link_count:0,link_keys:u,link_interfaces:s}},p=function(n){return n.dependencies.link_count==n.dependencies.link_keys.length},w=function(n,t){var u=n.split(":")[0],r=t.split(":")[0],f=i[r]._options.sealed||!1,e=i[r][t].sealed||!1,o=i[r][t].abstract||!1;if(o)throw new Error("Access Violation: Module ["+t+"] is abstract and can only be referenced as an interface");if((f||e)&&u!=r)throw new Error("Access Violation: Module ["+t+"] is seal to namespace ["+r+"] and can not be accessed from namespace ["+u+"]");return!0},b=function(n){var o=[],i=n.dependencies.link_keys,e=n.dependencies.link_interfaces,s=function(n){throw new Error('Resolve Exception: Module "'+i[n]+'" not found');},r,u;for(r in i)u=t[i[r]],u=f(u)=="compiled"?u:new s(r),!e[i[r]]||et(i[r],u,e[i[r]],t[e[i[r]]]),o.push(u);return o},k=function(n,t){var r=y(n),i;if(t[0]===s(n)){for(i in t[1])if(t[1][i]!=r[i])return i+1}else return!1;return!t[2]?!0:n.apply({},t[2])},et=function(n,t,i,u){var f,o,e;if(r&&console.log("Assert Interface:",n,t,"AS",i,u),s(t)=="function")if(!u.$constructor)throw new Error("Interface Exception: No $constructor definition found for constructor function. Interface ["+i+"] can not be applied to module ["+n+'] because module needs to be instanced by the constructor "new '+n+"("+t.toString().match(v)[1]+')"');else t=k(t,u.$constructor);for(f in u)if(f[0]!="$")if(!t[f])throw new Error("Interface Exception: Module ["+n+"] must implement property [("+u[f][0]+") "+f+" : "+u[f]+"] of interface ["+i+"]");else{o=s(t[f]);switch(u[f][0]){case"string":case"number":case"boolean":case"array":if(u[f][0]!=o)throw new Error("Interface Exception: Module ["+n+"] must implement property ["+f+" : "+u[f]+"] of interface ["+i+'] Expected type "'+u[f][0]+'" but found type "'+o+'"');break;case"function":if(e=k(t[f],u[f]),!e)throw new Error("Interface Exception: Module ["+n+"] must implement property ["+f+" : "+u[f]+"] of interface ["+i+'] Expected type "'+u[f][0]+'" but found type "'+o+'"');else if(!isNaN(parseFloat(e))&&isFinite(e)){e=e-1;throw new Error("Interface Exception: function argument mismatch in property "+f+'. Expected "'+u[f][1][e]+'" but found "'+y(t[f])+'" in "'+f+" : "+t[f]+'"');}}}return!0},ot=function(n,t,i,r){return{namespace:n,key:ut(n,r),type:i,dependencies:ft(t),builder:t[t.length-1]}},st=function(){var i,n,e;if(r&&console.log("Registered: ",this),a)throw new Error("Register Exception: rucksack has been locked and can not be altered");if(f(t[this.key])!="undefined")throw new Error("Register Exception: ["+this.key+"] has already been registered and can not be redefined");t[this.key]=this;for(i in this.dependencies.link_keys){n=this.dependencies.link_keys[i];e=t[n]=!t[n]?undefined:t[n];switch(f(e)){case"undefined":case"linking":u[n]=!u[n]?[]:u[n];u[n].push(this.key);r&&console.log("["+u[n]+"] is listening for ["+n+"]");break;case"compiled":r&&console.log(n,"is compiled try link now");w(this.key,n)&&this.dependencies.link_count++}}p(this)&&d(this.key)},d=function(n){r&&console.log("Try Compile: ",t[n]);var i={},u=b(t[n]);switch(t[n].type){case"service":t[n].builder.apply(i,u);break;case"factory":i=t[n].builder.apply(null,u);break;case"interface":i=t[n].builder();break;case"await":t[n].builder.apply(null,u);i=!0}t[n]=i;ht(n)},ht=function(n){var f,i;r&&console.log("Link [",n,"] with",u[n]||"[ No listening modules ]");for(f in u[n])i=u[n][f],r&&console.log(i,"is listening for",n),w(i,n)&&(t[i].dependencies.link_count++,p(t[i])&&d(i));delete u[n]},ct=function(n,t){g.$await(n,t)},lt=function(){a=!0},h=function(n,u){if(r&&console.log("Add namespace: ",n,u),!!i[n])throw new Error("Namespace Exception: The namespace ["+n+"] has already been defined");i[n]={_options:u||{}};var e=function(n,t,r,u,f){var o={},s,h,c;try{if(!!i[n]._options.frozen)throw new Error("Namespace Exception: The namespace ["+n+"] has been frozen and can not be added to");o=ot(n,r,u,t);i[n][o.key]=f||{};st.call(o)}catch(e){if(!!l){s="NOT SUPPORTED";h={name:e.name,message:e.message,lineNumber:e.lineNumber||e.line||s,stack:e.stack||s,$navigator:window.navigator,$datetime:(new Date).toLocaleString(),$ruckackScope:{module:o,descriptor:!i[n][o.key]?s:i[n][o.key].descriptor}};for(c in e)h[c]=e[c];l(h)}throw e;}},s=function(t,i,r){return e(n,t,i,"service",r),o},h=function(t,i,r){return e(n,t,i,"factory",r),o},a=function(t,i){return e(n,t,[function(){return i}],"interface",{abstract:!0,seal:!0}),o},v=function(n,t){e(c,n,t,"await",u)},w=function(r){if(!!!i[n][r])throw new Error("Reference Exception: Module ["+r+"] is not found in namespace ["+n+"]");var u=t[r],e=null;switch(f(u)){case"undefined":throw new Error("Reference Exception: Module ["+r+"] is not yet defined");case"linking":e=b(u);break;case"compiled":e=u}return e},y=function(t,r){if(t)return!r||!!i[n][t].descriptor||(i[n][t].descriptor=r),i[n][t].descriptor},p=function(){i[n]._options.frozen=!0},o={$service:s,$factory:h,$interface:a,$await:v,$describe:y,$freeze:p};return o},c="_AWAIT",g=h(c,{seal:!0});return{$namespace:h,$await:ct,$lock:lt,$reset:rt}}($RSConfig);
/*
//# sourceMappingURL=rucksack.min.js.map
*/